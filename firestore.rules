/**
 * This ruleset enforces a strict user-ownership security model for a user profile
 * management application. It is designed for rapid prototyping, focusing on
 * strong authorization while maintaining flexibility in the data schema.
 *
 * Core Philosophy:
 * The security model is centered around the principle that users have complete
 * and exclusive control over their own data. All data is scoped to the
 * authenticated user, and no user can read, write, or even list the data of
 * any other user.
 *
 * Data Structure:
 * All application data is organized under a top-level 'users' collection. Each
 * document in this collection represents a single user's profile, and the
 * document ID is the user's unique authentication UID.
 *   - /users/{userId}: A UserProfile document.
 *
 * Key Security Decisions:
 * - Strict Ownership: All access control checks verify that the authenticated
 *   user's UID (`request.auth.uid`) matches the `userId` in the document path.
 * - No User Enumeration: The ability to list all documents in the `/users`
 *   collection is explicitly disabled to protect user privacy and prevent data
 *   scraping. Users can only fetch their own profile document directly by its ID.
 * - Write Integrity: On creation, the rules ensure that the `id` field inside a
 *   user's profile document matches their UID. This field is then enforced as
 *   immutable on all subsequent updates, ensuring a permanent and reliable link
 *   between the document data and its owner.
 *
 * Denormalization for Authorization:
 * This ruleset relies on the document's ID (`userId`) as the primary source of
 * truth for ownership, which is the most direct and performant method. It also
 * validates an `id` field inside the document against the path to ensure data
 * integrity, a form of denormalization that solidifies the ownership link.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to provide clear, reusable, and auditable logic.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of the document,
     * based on the userId from the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the owner of an EXISTING document.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates required authorization fields during profile creation.
     * Ensures the internal 'id' field is consistent with the document's path ID.
     */
    function hasValidProfileDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates data on profile update, ensuring critical IDs are immutable.
     * Prevents re-assigning a profile document to a different user.
     */
    function hasValidProfileDataOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow (get) A user (auth.uid='user123') to read their own profile at /users/user123.
     * @allow (create) A new user (auth.uid='user123') to create their profile at /users/user123.
     * @deny (list) Any user from listing all documents in the /users collection.
     * @deny (update) A user (auth.uid='user456') from updating another user's profile at /users/user123.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidProfileDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidProfileDataOnUpdate();
      allow delete: if isExistingOwner(userId);
    }
  }
}